%!TEX root = Thesis.tex
\chapter{Foundations and Requirements Analysis}

The fundamental terms used in this thesis are described below for better understanding of the presented research work.
\section {Frontends}
In computer science, the front end is responsible for collecting input in various forms from the user and processing it to conform to a specification the backend can use. The frontend is an interface between the user and the backend\cite{wiki:xxx} and the separation of software systems into front and back ends simplifies development and separates maintenance. Therefore need to be distinguished what are the main requirements to a generic frontend for exploring sensed data.
\begin{itemize}
\item Loosely-coupling
\item Fine-grained structure
\item Multy-user capability
\item Cross-platforming
\item Adaptivity
\end{itemize}

\subsubsection {Web Portal}
Such a system, that generates requested information dynamically, displays that
information in a useful manner in Web, maintains control over the created/saved files, automatically updates
the information, and supports a distributed environment\cite{rezayat2000enterprise}.
A web portal is most often specially-designed Web page at a website which brings information together from diverse sources in a uniform way. Usually, each information source gets its dedicated area on the page for displaying information (a portlet); often, the user can configure which ones to display.Portals provide a way for enterprises and organizations to provide a consistent look and feel with access control and procedures for multiple applications and databases, which otherwise would have been different web entities at various URLs. The features available may be restricted by whether access is by an authorized and authenticated user (employee,member) or an anonymous site visitor\cite{wiki:portal}.

\subsubsection {Mashup}
The mashup application is a composite Web 2.0 application that aggregates and
integrates heterogeneous web resources offered in a form of available Web APIs and
sources for creating a new service. Mashups differ from traditional component-based
applications in providing more situational character of these applications\cite{yu2008understanding}.
In general there distinguish the following three types of mashups\cite{peenikal2009mashups}. 
Customer mashups are aimed at the combination and reformation data from various
public sources according to users’ needs. Data mashups aggregate similar types of
resources from diverse sources into a new single data representation. And business,
or enterprise, mashups define composite applications that are focused on solving
heterogeneous business problems by supporting collaborative activities\cite{hoyer2008enterprise}.
Concerning architectural styles of mashup applications,
 server-side and clientside mashups are distinguished. In the server-side mashups a content aggregation
is realized on a server. The server plays a role of a proxy between the
mashup application and other web sites that involved in this application. The
opposite client-side mashups aggregate content on a client, typically, at a client’s
web browser\cite{ort2007mashup}.
Earlier, composite web applications covered the integration at the low application
layers, such as the traditional data and business logic layers. However, mashups with
their intention to reuse pieces of user interfaces (UIs) from different web resources
increase the necessity of the UI integration, and the composition at the presentation
layer\cite{daniel2007understanding}. Several research approaches refer to the problem of the component-
based development of web applications at the presentation layer\cite{pietschmann2010application}.
\section {Data Sources}
\subsection {Sensors}
\subsection {Web}
\subsection {Generic Considerations}

\section{Concept Requirements}
Like most modern applications, each of these is structured into three layers: presentation, 
application (also called the business-logic layer), and data.
\begin{enumerate}
\item the granularity of the functions that the component applications provide is generally well
suited for high-level integration (for example, we can tell an application to begin monitoring
machine xyz without considering how this activity will affect data in the integrated application’s database)
\item it’s more stable because the component application is aware of the integration (it exposes
the API) and will attempt to stabilize the interface across versions
\end{enumerate}

\section{Summary}